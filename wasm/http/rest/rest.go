// Package rest provides a REST client for communicating with a GRPC gateway.
package rest

import (
	"bytes"
	"compress/flate"
	"compress/gzip"
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
)

// ContentType is the HTTP request header's content type for requests going to the grpc-gateway.
// If you are binding multiple services listeners to a port, you will need to route requests with
// this content-type to your runtime.ServeMux.
const ContentType = "application/grpc-gateway"

// DefaultHeaders returns the default headers used in our GRPC REST client. It is recommended that
// if you want to apply custom headers, you modify a header generated by this function.
func DefaultHeaders() http.Header {
	h := http.Header{}
	h.Add("Content-Type", ContentType)
	return h
}

// GRPC is a REST client for talking with a GRPC gateway. The backend handlers will receive
// content-type: application/grpc-gateway.
type GRPC struct {
	base   *url.URL
	client *http.Client
	header http.Header

	compressHandler CompressHandler

	decompressHandlers map[string]DecompressHandler
}

// CompressHandler creates an *http.Request that compresses the Body content.
type CompressHandler func(ctx context.Context, path string, headers http.Header, r io.Reader) (*http.Request, error)

// DecompressHandler takes an io.Reader and either compresses the content or
// decompresses the content to the returned io.ReadCloser.
type DecompressHandler func(r io.Reader) io.Reader

// Option provides an optional argument to the New() constructor.
type Option func(g *GRPC)

// CustomClient allows providing a custom http client for contacting GRPC's gateway proxy.
// By default, we use a client with defaults set (we do not use the built in client).
func CustomClient(h *http.Client) Option {
	return func(g *GRPC) {
		g.client = h
	}
}

// CustomHeaders provides a custom header to be sent on each call. The default headers set only one value,
// "content-type", which is set to the constant ContentType defined in this file. This is also
// useful for setting JS Fetch() call options when doing WASM:
// https://github.com/golang/go/wiki/WebAssembly#configuring-fetch-options-while-using-nethttp
func CustomHeaders(header http.Header) Option {
	return func(g *GRPC) {
		g.header = header
	}
}

// CompressRequests will compress all http.Request.Body content with the Compression handler provided
// here. The REST service will need need to be able to understand the Content-Encoding
// and decompress it before grpc-gateway receives the message.
func CompressRequests(h CompressHandler) Option {
	return func(g *GRPC) {
		g.compressHandler = h
	}
}

// DecompressResponse allows decompression of responses sent from the server with the "acceptEncoding" using
// the provided DecompressHandler. By default, we already support gzip("gzip") and deflate("deflate").
// You may provide this option multiple times for multiple acceptEncodings.
func DecompressResponse(acceptEncoding string, h DecompressHandler) Option {
	return func(g *GRPC) {
		g.decompressHandlers[acceptEncoding] = h
	}
}

// New is the constructor for talking with the GRPC gateway. endpoint is a url that starts with
// http/https and ends with :port (https://192.168.1.1:8082) representing the grpc-gateway endpoint.
func New(endpoint *url.URL, options ...Option) *GRPC {
	g := &GRPC{
		base:   endpoint,
		client: &http.Client{},
		header: DefaultHeaders(),
		decompressHandlers: map[string]DecompressHandler{
			"gzip":    gzipDecompress,
			"deflate": defalteDecompress,
		},
	}

	for _, o := range options {
		o(g)
	}

	for enc := range g.decompressHandlers {
		g.header.Add("Accept-Encoding", enc)
	}

	return g
}

// Call calls a non-streaming RPC at path, where path is the relative URL of the call (/v1/snippetsService/save).
// Args is the proto message that will be sent and result is the proto message that is expected to be returned.
// Call will honor timeouts and cancels from the Context object.
func (g *GRPC) Call(ctx context.Context, path string, args proto.Message, result proto.Message) error {
	b, err := protojson.Marshal(args)
	if err != nil {
		return fmt.Errorf("grpc.Call(): %T could not be json marshalled: %w", args, err)
	}

	ref, err := url.Parse(path)
	if err != nil {
		return fmt.Errorf("grpc.Call(): could not parse path URL(%s): %w", path, err)
	}

	fullPath := g.base.ResolveReference(ref).String()

	var req *http.Request
	// Apply compression to request body if needed.
	if g.compressHandler != nil {
		req, err = g.compressHandler(ctx, fullPath, g.header, bytes.NewBuffer(b))
		if err != nil {
			return fmt.Errorf("grpc.Call(): failed to create a request: %w", err)
		}
	} else {
		req, err = http.NewRequestWithContext(ctx, "POST", fullPath, bytes.NewBuffer(b))
		if err != nil {
			return fmt.Errorf("grpc.Call(): failed to create a request: %w", err)
		}
		req.Header = g.header
	}

	resp, err := g.client.Do(req)
	if err != nil {
		return fmt.Errorf("grpc.Call(): client had error connecting to service: %w", err)
	}

	if resp.StatusCode != 200 {
		content, _ := ioutil.ReadAll(resp.Body)
		return fmt.Errorf("grpc.Call(): service returned a non-200 status code(%d): %s", resp.StatusCode, string(content))
	}

	// Decompress response, if needed.
	reader, err := g.handleDecompress(resp)
	if err != nil {
		return fmt.Errorf("grpc.Call(): client had error finding a decompressor: %w", err)
	}

	content, err := ioutil.ReadAll(reader)
	if err != nil {
		return fmt.Errorf("grpc.Call(): client had error reading response: %w", err)
	}

	if err := protojson.Unmarshal(content, result); err != nil {
		return fmt.Errorf("grpc.Call(%s): had error unmarshalling response body into %T: %w", path, result, err)
	}
	return nil
}

// handleDecompress looks at the Content-Encoding and provides the appropriate decompressor if
// we have one.
func (g *GRPC) handleDecompress(resp *http.Response) (io.Reader, error) {
	// This field indicates that our client uncompressed the response for us by default.
	// This is only set when the server does this, it is not an overall indication if the response
	// is uncompressed.
	if resp.Uncompressed {
		return resp.Body, nil
	}

	ce := resp.Header.Get("Content-Encoding")
	if ce == "" {
		return resp.Body, nil
	}

	handler := g.decompressHandlers[ce]
	if handler == nil {
		return nil, fmt.Errorf("rest.GRPC.Call(): received Content-Encoding %s, which we do not support", ce)
	}

	return handler(resp.Body), nil
}

// GzipCompress implements CompressHandler to allow compressing requests to the server.
func GzipCompress(ctx context.Context, path string, headers http.Header, r io.Reader) (*http.Request, error) {
	pipeOut, pipeIn := io.Pipe()
	w := gzip.NewWriter(pipeIn)

	go func() {
		_, err := io.Copy(w, r)
		if err != nil {
			pipeIn.CloseWithError(err)
			w.Close()
			return
		}
		if err := w.Close(); err != nil {
			pipeIn.CloseWithError(err)
			return
		}
		pipeIn.Close()
	}()

	req, err := http.NewRequestWithContext(ctx, "POST", path, pipeOut)
	if err != nil {
		return nil, err
	}
	if headers != nil {
		req.Header = headers
	}
	req.Header.Add("Content-Encoding", "gzip")
	return req, nil
}

// gzipDecompress implements DecompressHandler for decompressing gzip content.
func gzipDecompress(r io.Reader) io.Reader {
	gzipReader, _ := gzip.NewReader(r)

	pipeOut, pipeIn := io.Pipe()
	go func() {
		_, err := io.Copy(pipeIn, gzipReader)
		if err != nil {
			pipeIn.CloseWithError(err)
			gzipReader.Close()
			return
		}
		if err := gzipReader.Close(); err != nil {
			pipeIn.CloseWithError(err)
			return
		}
		pipeIn.Close()
	}()
	return pipeOut
}

// defalteDecompress implements DecompressHandler for decompressing deflate content.
func defalteDecompress(r io.Reader) io.Reader {
	flateReader := flate.NewReader(r)

	pipeOut, pipeIn := io.Pipe()
	go func() {
		_, err := io.Copy(pipeIn, flateReader)
		if err != nil {
			pipeIn.CloseWithError(err)
			flateReader.Close()
			return
		}
		if err := flateReader.Close(); err != nil {
			pipeIn.CloseWithError(err)
			return
		}
		pipeIn.Close()
	}()
	return pipeOut
}
